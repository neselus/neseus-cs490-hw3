{
  "version": 3,
  "sources": ["../../src/lib/auth.js"],
  "sourcesContent": ["import { AuthenticationError, ForbiddenError } from '@redwoodjs/graphql-server'\n\nimport { db } from './db'\n\n/**\n * The session object sent in as the first argument to getCurrentUser() will\n * have a single key `id` containing the unique ID of the logged in user\n * (whatever field you set as `authFields.id` in your auth function config).\n * You'll need to update the call to `db` below if you use a different model\n * name or unique field name, for example:\n *\n *   return await db.profile.findUnique({ where: { email: session.id } })\n *                   ───┬───                       ──┬──\n *      model accessor ─┘      unique id field name ─┘\n *\n * !! BEWARE !! Anything returned from this function will be available to the\n * client--it becomes the content of `currentUser` on the web side (as well as\n * `context.currentUser` on the api side). You should carefully add additional\n * fields to the `select` object below once you've decided they are safe to be\n * seen if someone were to open the Web Inspector in their browser.\n */\nexport const getCurrentUser = async (session) => {\n  return await db.user.findUnique({\n    where: { id: session.id },\n    select: { id: true, email: true, roles: true },\n  })\n}\n\n/**\n * The user is authenticated if there is a currentUser in the context\n *\n * @returns {boolean} - If the currentUser is authenticated\n */\nexport const isAuthenticated = () => {\n  return !!context.currentUser\n}\n\n/**\n * When checking role membership, roles can be a single value, a list, or none.\n * You can use Prisma enums too (if you're using them for roles), just import your enum type from `@prisma/client`\n */\n\n/**\n * Checks if the currentUser is authenticated (and assigned one of the given roles)\n *\n * @param roles: {@link AllowedRoles} - Checks if the currentUser is assigned one of these roles\n *\n * @returns {boolean} - Returns true if the currentUser is logged in and assigned one of the given roles,\n * or when no roles are provided to check against. Otherwise returns false.\n */\nexport const hasRole = (roles) => {\n  if (!isAuthenticated()) {\n    return false\n  }\n\n  const currentUserRoles = context.currentUser?.roles\n\n  if (typeof roles === 'string') {\n    if (typeof currentUserRoles === 'string') {\n      // roles to check is a string, currentUser.roles is a string\n      return currentUserRoles === roles\n    } else if (Array.isArray(currentUserRoles)) {\n      // roles to check is a string, currentUser.roles is an array\n      return currentUserRoles?.some((allowedRole) => roles === allowedRole)\n    }\n  }\n\n  if (Array.isArray(roles)) {\n    if (Array.isArray(currentUserRoles)) {\n      // roles to check is an array, currentUser.roles is an array\n      return currentUserRoles?.some((allowedRole) =>\n        roles.includes(allowedRole)\n      )\n    } else if (typeof currentUserRoles === 'string') {\n      // roles to check is an array, currentUser.roles is a string\n      return roles.some((allowedRole) => currentUserRoles === allowedRole)\n    }\n  }\n\n  // roles not found\n  return false\n}\n\n/**\n * Use requireAuth in your services to check that a user is logged in,\n * whether or not they are assigned a role, and optionally raise an\n * error if they're not.\n *\n * @param roles: {@link AllowedRoles} - When checking role membership, these roles grant access.\n *\n * @returns - If the currentUser is authenticated (and assigned one of the given roles)\n *\n * @throws {@link AuthenticationError} - If the currentUser is not authenticated\n * @throws {@link ForbiddenError} If the currentUser is not allowed due to role permissions\n *\n * @see https://github.com/redwoodjs/redwood/tree/main/packages/auth for examples\n */\nexport const requireAuth = ({ roles } = {}) => {\n  if (!isAuthenticated()) {\n    throw new AuthenticationError(\"You don't have permission to do that.\")\n  }\n\n  if (roles && !hasRole(roles)) {\n    throw new ForbiddenError(\"You don't have access to do that.\")\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,4BAAoD;AAEpD,gBAAW;AAmBJ,MAAMA,iBAAiB,OAAOC,YAAY;AAC/C,SAAO,MAAMC,aAAGC,KAAKC,WAAW;IAC9BC,OAAO;MAAEC,IAAIL,QAAQK;IAAG;IACxBC,QAAQ;MAAED,IAAI;MAAME,OAAO;MAAMC,OAAO;IAAK;EAC/C,CAAC;AACH;AAOO,MAAMC,kBAAkBA,MAAM;AACnC,SAAO,CAAC,CAACC,8BAAQC;AACnB;AAeO,MAAMC,UAAWJ,WAAU;AAChC,MAAI,CAACC,gBAAgB,GAAG;AACtB,WAAO;EACT;AAEA,QAAMI,mBAAmBH,8BAAQC,aAAaH;AAE9C,MAAI,OAAOA,UAAU,UAAU;AAC7B,QAAI,OAAOK,qBAAqB,UAAU;AAExC,aAAOA,qBAAqBL;IAC9B,eAAWM,gBAAAA,SAAcD,gBAAgB,GAAG;AAE1C,aAAOA,kBAAkBE,KAAMC,iBAAgBR,UAAUQ,WAAW;IACtE;EACF;AAEA,UAAIF,gBAAAA,SAAcN,KAAK,GAAG;AACxB,YAAIM,gBAAAA,SAAcD,gBAAgB,GAAG;AAEnC,aAAOA,kBAAkBE,KAAMC,qBAC7BC,gBAAAA,SAAAT,KAAK,EAAAU,KAALV,OAAeQ,WAAW,CAC5B;IACF,WAAW,OAAOH,qBAAqB,UAAU;AAE/C,iBAAOM,YAAAA,SAAAX,KAAK,EAAAU,KAALV,OAAYQ,iBAAgBH,qBAAqBG,WAAW;IACrE;EACF;AAGA,SAAO;AACT;AAgBO,MAAMI,cAAcA,CAAC;EAAEZ;AAAM,IAAI,CAAC,MAAM;AAC7C,MAAI,CAACC,gBAAgB,GAAG;AACtB,UAAM,IAAIY,0CAAoB,uCAAuC;EACvE;AAEA,MAAIb,SAAS,CAACI,QAAQJ,KAAK,GAAG;AAC5B,UAAM,IAAIc,qCAAe,mCAAmC;EAC9D;AACF;",
  "names": ["getCurrentUser", "session", "db", "user", "findUnique", "where", "id", "select", "email", "roles", "isAuthenticated", "context", "currentUser", "hasRole", "currentUserRoles", "_Array$isArray", "some", "allowedRole", "_includesInstanceProperty", "call", "_someInstanceProperty", "requireAuth", "AuthenticationError", "ForbiddenError"]
}
